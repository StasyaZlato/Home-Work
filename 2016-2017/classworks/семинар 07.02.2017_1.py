# ^ и $ - начало и конец строк
# [^абв] - инвертированный класс (не а, не б, не в)
# Внутри [] не работают обычные рег выр
# квантификаторы: * - любое кол-во пред.символа 0-..., + - любое кол-во 1-...,
# {5} - пред.выр. должно встретиться 5 раз, {3,5} - от 3 до 5 раз, {,5} - не более 5 раз, {3,} - не менее 3 раз
# {,} = *, {1,} = +, {,1} = ?
# ^, $ могут использоваться несколько раз
# ([ghjfhdsh].*){3} - найдет с любыми согл. из списка (gafaju)
# \s - любой пробелообразный символ (пробел, табуляция, новая строка)
# \w - any letter
# \d - any number
# shift+ctrl+_ = неразрывный пробел в ворде:)
# \W - any not-letter
# \D - any not-number
# \b - граница слова
# \bкот\b - 'кот', \sкот\s - ' кот '
# поиск. m = re.search(regex, string) - ищет совпадения В ЛЮБОМ МЕСТЕ СТРОКИ
# m = re.match(regex,string) - ищет С НАЧАЛА СТРОКИ
# findall - ищет ВСЕ вхождения
# Результат поиска - НЕ СТРОКА, если ничего - None, если нашлось - атрибуты
# m.group() - найти группу (...), нумеруется по открывающим скобкам
# результат поиска m - объект типа match, group - метод
# m.group(0) - все выражение, m.group(3) - найти третью группу
# m.start(x) - номер первого символа группы номер x в строке
# m.end(x) - -//- последнего -//-
# (?:abc) - незапоминающая группа (не войдет в m.group()): 1()2()(?:abc)3()
# обратные ссылки - способо использовать уже найденную группу в дальнейшем поиске
# ([ауеиоыюяэё]).*\\1.*\\1 - слова с 3 ОДИНАКОВЫМИ гласными
# (а?)б\\1 - сработает на строке б, (а)?б\\1 - не сработает на строке б
# жадные квантификаторы: *, +, ?, {min,max} - берет ВСЕ символы, подходящие к выр.
# нежадные квантификаторы: *?, +?, ??, {min, max}?
# текст в скобках: \\([^\\...
# элементами массива могут быть другие массивы: [[],[]]...
# a = re.findall(u'[^;]+', s), ы = 'Петя; 1234; прови'
# возвращает массив ['Петя', '1234', 'прови']
# если есть группы - массив массивов
# ЭКРАНИРОВАНИЕ: \\w, ИЛИ r'\w...'
